// Code generated by protoc-gen-gogo.
// source: bfe_waf.proto
// DO NOT EDIT!

/*
	Package test_pb is a generated protocol buffer package.

	It is generated from these files:
		bfe_waf.proto

	It has these top-level messages:
		Header
		Request
		WafRequest
		WafResponse
*/
package test_pb

import proto "code.google.com/p/gogoprotobuf/proto"
import math "math"

// discarding unused import gogoproto "code.google.com/p/gogoprotobuf/gogoproto/gogo.pb"

import io "io"
import fmt "fmt"
import code_google_com_p_gogoprotobuf_proto "code.google.com/p/gogoprotobuf/proto"

import fmt1 "fmt"
import strings "strings"
import reflect "reflect"

import fmt2 "fmt"
import strings1 "strings"
import code_google_com_p_gogoprotobuf_proto1 "code.google.com/p/gogoprotobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect1 "reflect"

import fmt3 "fmt"
import bytes "bytes"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type Method int32

const (
	Method_GET    Method = 0
	Method_POST   Method = 1
	Method_PUT    Method = 2
	Method_DELETE Method = 3
)

var Method_name = map[int32]string{
	0: "GET",
	1: "POST",
	2: "PUT",
	3: "DELETE",
}
var Method_value = map[string]int32{
	"GET":    0,
	"POST":   1,
	"PUT":    2,
	"DELETE": 3,
}

func (x Method) Enum() *Method {
	p := new(Method)
	*p = x
	return p
}
func (x Method) String() string {
	return proto.EnumName(Method_name, int32(x))
}
func (x *Method) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Method_value, data, "Method")
	if err != nil {
		return err
	}
	*x = Method(value)
	return nil
}

type Version int32

const (
	Version_HTTP_1_0 Version = 0
	Version_HTTP_1_1 Version = 1
)

var Version_name = map[int32]string{
	0: "HTTP_1_0",
	1: "HTTP_1_1",
}
var Version_value = map[string]int32{
	"HTTP_1_0": 0,
	"HTTP_1_1": 1,
}

func (x Version) Enum() *Version {
	p := new(Version)
	*p = x
	return p
}
func (x Version) String() string {
	return proto.EnumName(Version_name, int32(x))
}
func (x *Version) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Version_value, data, "Version")
	if err != nil {
		return err
	}
	*x = Version(value)
	return nil
}

type ResponseCode int32

const (
	ResponseCode_OK        ResponseCode = 0
	ResponseCode_FORBIDDEN ResponseCode = 1
)

var ResponseCode_name = map[int32]string{
	0: "OK",
	1: "FORBIDDEN",
}
var ResponseCode_value = map[string]int32{
	"OK":        0,
	"FORBIDDEN": 1,
}

func (x ResponseCode) Enum() *ResponseCode {
	p := new(ResponseCode)
	*p = x
	return p
}
func (x ResponseCode) String() string {
	return proto.EnumName(ResponseCode_name, int32(x))
}
func (x *ResponseCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ResponseCode_value, data, "ResponseCode")
	if err != nil {
		return err
	}
	*x = ResponseCode(value)
	return nil
}

type Header struct {
	Key              *string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Header) Reset()      { *m = Header{} }
func (*Header) ProtoMessage() {}

func (m *Header) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Header) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type Request struct {
	Method           *Method   `protobuf:"varint,1,opt,name=method,enum=test_pb.Method" json:"method,omitempty"`
	Version          *Version  `protobuf:"varint,2,opt,name=version,enum=test_pb.Version" json:"version,omitempty"`
	Uri              *string   `protobuf:"bytes,3,opt,name=uri" json:"uri,omitempty"`
	Headers          []*Header `protobuf:"bytes,4,rep,name=headers" json:"headers,omitempty"`
	Body             []byte    `protobuf:"bytes,5,opt,name=body" json:"body,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Request) Reset()      { *m = Request{} }
func (*Request) ProtoMessage() {}

func (m *Request) GetMethod() Method {
	if m != nil && m.Method != nil {
		return *m.Method
	}
	return Method_GET
}

func (m *Request) GetVersion() Version {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return Version_HTTP_1_0
}

func (m *Request) GetUri() string {
	if m != nil && m.Uri != nil {
		return *m.Uri
	}
	return ""
}

func (m *Request) GetHeaders() []*Header {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *Request) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type WafRequest struct {
	Service          *string  `protobuf:"bytes,1,opt,name=service" json:"service,omitempty"`
	Signature        *string  `protobuf:"bytes,2,opt,name=signature" json:"signature,omitempty"`
	Req              *Request `protobuf:"bytes,3,opt,name=req" json:"req,omitempty"`
	Clientip         *uint32  `protobuf:"varint,4,opt,name=clientip" json:"clientip,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *WafRequest) Reset()      { *m = WafRequest{} }
func (*WafRequest) ProtoMessage() {}

func (m *WafRequest) GetService() string {
	if m != nil && m.Service != nil {
		return *m.Service
	}
	return ""
}

func (m *WafRequest) GetSignature() string {
	if m != nil && m.Signature != nil {
		return *m.Signature
	}
	return ""
}

func (m *WafRequest) GetReq() *Request {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *WafRequest) GetClientip() uint32 {
	if m != nil && m.Clientip != nil {
		return *m.Clientip
	}
	return 0
}

type WafResponse struct {
	Code             *ResponseCode `protobuf:"varint,1,opt,name=code,enum=test_pb.ResponseCode" json:"code,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *WafResponse) Reset()      { *m = WafResponse{} }
func (*WafResponse) ProtoMessage() {}

func (m *WafResponse) GetCode() ResponseCode {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return ResponseCode_OK
}

func init() {
	proto.RegisterEnum("test_pb.Method", Method_name, Method_value)
	proto.RegisterEnum("test_pb.Version", Version_name, Version_value)
	proto.RegisterEnum("test_pb.ResponseCode", ResponseCode_name, ResponseCode_value)
}
func (m *Header) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[index:postIndex])
			m.Key = &s
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[index:postIndex])
			m.Value = &s
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := code_google_com_p_gogoprotobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *Request) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var v Method
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (Method(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Method = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v Version
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (Version(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Version = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[index:postIndex])
			m.Uri = &s
			index = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &Header{})
			m.Headers[len(m.Headers)-1].Unmarshal(data[index:postIndex])
			index = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body, data[index:postIndex]...)
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := code_google_com_p_gogoprotobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *WafRequest) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[index:postIndex])
			m.Service = &s
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[index:postIndex])
			m.Signature = &s
			index = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Req == nil {
				m.Req = &Request{}
			}
			if err := m.Req.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clientip", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Clientip = &v
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := code_google_com_p_gogoprotobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *WafResponse) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v ResponseCode
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (ResponseCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Code = &v
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := code_google_com_p_gogoprotobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (this *Header) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Header{`,
		`Key:` + valueToStringBfeWaf(this.Key) + `,`,
		`Value:` + valueToStringBfeWaf(this.Value) + `,`,
		`XXX_unrecognized:` + fmt1.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Request) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Request{`,
		`Method:` + valueToStringBfeWaf(this.Method) + `,`,
		`Version:` + valueToStringBfeWaf(this.Version) + `,`,
		`Uri:` + valueToStringBfeWaf(this.Uri) + `,`,
		`Headers:` + strings.Replace(fmt1.Sprintf("%v", this.Headers), "Header", "Header", 1) + `,`,
		`Body:` + valueToStringBfeWaf(this.Body) + `,`,
		`XXX_unrecognized:` + fmt1.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafRequest{`,
		`Service:` + valueToStringBfeWaf(this.Service) + `,`,
		`Signature:` + valueToStringBfeWaf(this.Signature) + `,`,
		`Req:` + strings.Replace(fmt1.Sprintf("%v", this.Req), "Request", "Request", 1) + `,`,
		`Clientip:` + valueToStringBfeWaf(this.Clientip) + `,`,
		`XXX_unrecognized:` + fmt1.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafResponse{`,
		`Code:` + valueToStringBfeWaf(this.Code) + `,`,
		`XXX_unrecognized:` + fmt1.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringBfeWaf(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt1.Sprintf("*%v", pv)
}
func (m *Header) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovBfeWaf(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovBfeWaf(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}
func (m *Request) Size() (n int) {
	var l int
	_ = l
	if m.Method != nil {
		n += 1 + sovBfeWaf(uint64(*m.Method))
	}
	if m.Version != nil {
		n += 1 + sovBfeWaf(uint64(*m.Version))
	}
	if m.Uri != nil {
		l = len(*m.Uri)
		n += 1 + l + sovBfeWaf(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovBfeWaf(uint64(l))
		}
	}
	if m.Body != nil {
		l = len(m.Body)
		n += 1 + l + sovBfeWaf(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}
func (m *WafRequest) Size() (n int) {
	var l int
	_ = l
	if m.Service != nil {
		l = len(*m.Service)
		n += 1 + l + sovBfeWaf(uint64(l))
	}
	if m.Signature != nil {
		l = len(*m.Signature)
		n += 1 + l + sovBfeWaf(uint64(l))
	}
	if m.Req != nil {
		l = m.Req.Size()
		n += 1 + l + sovBfeWaf(uint64(l))
	}
	if m.Clientip != nil {
		n += 1 + sovBfeWaf(uint64(*m.Clientip))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}
func (m *WafResponse) Size() (n int) {
	var l int
	_ = l
	if m.Code != nil {
		n += 1 + sovBfeWaf(uint64(*m.Code))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBfeWaf(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBfeWaf(x uint64) (n int) {
	return sovBfeWaf(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func NewPopulatedHeader(r randyBfeWaf, easy bool) *Header {
	this := &Header{}
	if r.Intn(10) != 0 {
		v1 := randStringBfeWaf(r)
		this.Key = &v1
	}
	if r.Intn(10) != 0 {
		v2 := randStringBfeWaf(r)
		this.Value = &v2
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedBfeWaf(r, 3)
	}
	return this
}

func NewPopulatedRequest(r randyBfeWaf, easy bool) *Request {
	this := &Request{}
	if r.Intn(10) != 0 {
		v3 := Method([]int32{0, 1, 2, 3}[r.Intn(4)])
		this.Method = &v3
	}
	if r.Intn(10) != 0 {
		v4 := Version([]int32{0, 1}[r.Intn(2)])
		this.Version = &v4
	}
	if r.Intn(10) != 0 {
		v5 := randStringBfeWaf(r)
		this.Uri = &v5
	}
	if r.Intn(10) != 0 {
		v6 := r.Intn(10)
		this.Headers = make([]*Header, v6)
		for i := 0; i < v6; i++ {
			this.Headers[i] = NewPopulatedHeader(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v7 := r.Intn(100)
		this.Body = make([]byte, v7)
		for i := 0; i < v7; i++ {
			this.Body[i] = byte(r.Intn(256))
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedBfeWaf(r, 6)
	}
	return this
}

func NewPopulatedWafRequest(r randyBfeWaf, easy bool) *WafRequest {
	this := &WafRequest{}
	if r.Intn(10) != 0 {
		v8 := randStringBfeWaf(r)
		this.Service = &v8
	}
	if r.Intn(10) != 0 {
		v9 := randStringBfeWaf(r)
		this.Signature = &v9
	}
	if r.Intn(10) != 0 {
		this.Req = NewPopulatedRequest(r, easy)
	}
	if r.Intn(10) != 0 {
		v10 := r.Uint32()
		this.Clientip = &v10
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedBfeWaf(r, 5)
	}
	return this
}

func NewPopulatedWafResponse(r randyBfeWaf, easy bool) *WafResponse {
	this := &WafResponse{}
	if r.Intn(10) != 0 {
		v11 := ResponseCode([]int32{0, 1}[r.Intn(2)])
		this.Code = &v11
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedBfeWaf(r, 2)
	}
	return this
}

type randyBfeWaf interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneBfeWaf(r randyBfeWaf) rune {
	res := rune(r.Uint32() % 1112064)
	if 55296 <= res {
		res += 2047
	}
	return res
}
func randStringBfeWaf(r randyBfeWaf) string {
	v12 := r.Intn(100)
	tmps := make([]rune, v12)
	for i := 0; i < v12; i++ {
		tmps[i] = randUTF8RuneBfeWaf(r)
	}
	return string(tmps)
}
func randUnrecognizedBfeWaf(r randyBfeWaf, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldBfeWaf(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldBfeWaf(data []byte, r randyBfeWaf, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateBfeWaf(data, uint64(key))
		v13 := r.Int63()
		if r.Intn(2) == 0 {
			v13 *= -1
		}
		data = encodeVarintPopulateBfeWaf(data, uint64(v13))
	case 1:
		data = encodeVarintPopulateBfeWaf(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateBfeWaf(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateBfeWaf(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateBfeWaf(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateBfeWaf(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *Header) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Header) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		data[i] = 0xa
		i++
		i = encodeVarintBfeWaf(data, i, uint64(len(*m.Key)))
		i += copy(data[i:], *m.Key)
	}
	if m.Value != nil {
		data[i] = 0x12
		i++
		i = encodeVarintBfeWaf(data, i, uint64(len(*m.Value)))
		i += copy(data[i:], *m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}
func (m *Request) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Request) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Method != nil {
		data[i] = 0x8
		i++
		i = encodeVarintBfeWaf(data, i, uint64(*m.Method))
	}
	if m.Version != nil {
		data[i] = 0x10
		i++
		i = encodeVarintBfeWaf(data, i, uint64(*m.Version))
	}
	if m.Uri != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintBfeWaf(data, i, uint64(len(*m.Uri)))
		i += copy(data[i:], *m.Uri)
	}
	if len(m.Headers) > 0 {
		for _, msg := range m.Headers {
			data[i] = 0x22
			i++
			i = encodeVarintBfeWaf(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Body != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintBfeWaf(data, i, uint64(len(m.Body)))
		i += copy(data[i:], m.Body)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}
func (m *WafRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WafRequest) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Service != nil {
		data[i] = 0xa
		i++
		i = encodeVarintBfeWaf(data, i, uint64(len(*m.Service)))
		i += copy(data[i:], *m.Service)
	}
	if m.Signature != nil {
		data[i] = 0x12
		i++
		i = encodeVarintBfeWaf(data, i, uint64(len(*m.Signature)))
		i += copy(data[i:], *m.Signature)
	}
	if m.Req != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintBfeWaf(data, i, uint64(m.Req.Size()))
		n1, err := m.Req.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Clientip != nil {
		data[i] = 0x20
		i++
		i = encodeVarintBfeWaf(data, i, uint64(*m.Clientip))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}
func (m *WafResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WafResponse) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != nil {
		data[i] = 0x8
		i++
		i = encodeVarintBfeWaf(data, i, uint64(*m.Code))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}
func encodeFixed64BfeWaf(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32BfeWaf(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintBfeWaf(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (this *Header) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings1.Join([]string{`&test_pb.Header{` + `Key:` + valueToGoStringBfeWaf(this.Key, "string"), `Value:` + valueToGoStringBfeWaf(this.Value, "string"), `XXX_unrecognized:` + fmt2.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func (this *Request) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings1.Join([]string{`&test_pb.Request{` + `Method:` + valueToGoStringBfeWaf(this.Method, "test_pb.Method"), `Version:` + valueToGoStringBfeWaf(this.Version, "test_pb.Version"), `Uri:` + valueToGoStringBfeWaf(this.Uri, "string"), `Headers:` + fmt2.Sprintf("%#v", this.Headers), `Body:` + valueToGoStringBfeWaf(this.Body, "byte"), `XXX_unrecognized:` + fmt2.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func (this *WafRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings1.Join([]string{`&test_pb.WafRequest{` + `Service:` + valueToGoStringBfeWaf(this.Service, "string"), `Signature:` + valueToGoStringBfeWaf(this.Signature, "string"), `Req:` + fmt2.Sprintf("%#v", this.Req), `Clientip:` + valueToGoStringBfeWaf(this.Clientip, "uint32"), `XXX_unrecognized:` + fmt2.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func (this *WafResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings1.Join([]string{`&test_pb.WafResponse{` + `Code:` + valueToGoStringBfeWaf(this.Code, "test_pb.ResponseCode"), `XXX_unrecognized:` + fmt2.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func valueToGoStringBfeWaf(v interface{}, typ string) string {
	rv := reflect1.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect1.Indirect(rv).Interface()
	return fmt2.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringBfeWaf(e map[int32]code_google_com_p_gogoprotobuf_proto1.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings1.Join(ss, ",") + "}"
	return s
}
func (this *Header) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt3.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Header)
	if !ok {
		return fmt3.Errorf("that is not of type *Header")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt3.Errorf("that is type *Header but is nil && this != nil")
	} else if this == nil {
		return fmt3.Errorf("that is type *Headerbut is not nil && this == nil")
	}
	if this.Key != nil && that1.Key != nil {
		if *this.Key != *that1.Key {
			return fmt3.Errorf("Key this(%v) Not Equal that(%v)", *this.Key, *that1.Key)
		}
	} else if this.Key != nil {
		return fmt3.Errorf("this.Key == nil && that.Key != nil")
	} else if that1.Key != nil {
		return fmt3.Errorf("Key this(%v) Not Equal that(%v)", this.Key, that1.Key)
	}
	if this.Value != nil && that1.Value != nil {
		if *this.Value != *that1.Value {
			return fmt3.Errorf("Value this(%v) Not Equal that(%v)", *this.Value, *that1.Value)
		}
	} else if this.Value != nil {
		return fmt3.Errorf("this.Value == nil && that.Value != nil")
	} else if that1.Value != nil {
		return fmt3.Errorf("Value this(%v) Not Equal that(%v)", this.Value, that1.Value)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt3.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Header) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Header)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Key != nil && that1.Key != nil {
		if *this.Key != *that1.Key {
			return false
		}
	} else if this.Key != nil {
		return false
	} else if that1.Key != nil {
		return false
	}
	if this.Value != nil && that1.Value != nil {
		if *this.Value != *that1.Value {
			return false
		}
	} else if this.Value != nil {
		return false
	} else if that1.Value != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Request) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt3.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Request)
	if !ok {
		return fmt3.Errorf("that is not of type *Request")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt3.Errorf("that is type *Request but is nil && this != nil")
	} else if this == nil {
		return fmt3.Errorf("that is type *Requestbut is not nil && this == nil")
	}
	if this.Method != nil && that1.Method != nil {
		if *this.Method != *that1.Method {
			return fmt3.Errorf("Method this(%v) Not Equal that(%v)", *this.Method, *that1.Method)
		}
	} else if this.Method != nil {
		return fmt3.Errorf("this.Method == nil && that.Method != nil")
	} else if that1.Method != nil {
		return fmt3.Errorf("Method this(%v) Not Equal that(%v)", this.Method, that1.Method)
	}
	if this.Version != nil && that1.Version != nil {
		if *this.Version != *that1.Version {
			return fmt3.Errorf("Version this(%v) Not Equal that(%v)", *this.Version, *that1.Version)
		}
	} else if this.Version != nil {
		return fmt3.Errorf("this.Version == nil && that.Version != nil")
	} else if that1.Version != nil {
		return fmt3.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if this.Uri != nil && that1.Uri != nil {
		if *this.Uri != *that1.Uri {
			return fmt3.Errorf("Uri this(%v) Not Equal that(%v)", *this.Uri, *that1.Uri)
		}
	} else if this.Uri != nil {
		return fmt3.Errorf("this.Uri == nil && that.Uri != nil")
	} else if that1.Uri != nil {
		return fmt3.Errorf("Uri this(%v) Not Equal that(%v)", this.Uri, that1.Uri)
	}
	if len(this.Headers) != len(that1.Headers) {
		return fmt3.Errorf("Headers this(%v) Not Equal that(%v)", len(this.Headers), len(that1.Headers))
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return fmt3.Errorf("Headers this[%v](%v) Not Equal that[%v](%v)", i, this.Headers[i], i, that1.Headers[i])
		}
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return fmt3.Errorf("Body this(%v) Not Equal that(%v)", this.Body, that1.Body)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt3.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Request) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Request)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Method != nil && that1.Method != nil {
		if *this.Method != *that1.Method {
			return false
		}
	} else if this.Method != nil {
		return false
	} else if that1.Method != nil {
		return false
	}
	if this.Version != nil && that1.Version != nil {
		if *this.Version != *that1.Version {
			return false
		}
	} else if this.Version != nil {
		return false
	} else if that1.Version != nil {
		return false
	}
	if this.Uri != nil && that1.Uri != nil {
		if *this.Uri != *that1.Uri {
			return false
		}
	} else if this.Uri != nil {
		return false
	} else if that1.Uri != nil {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *WafRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt3.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*WafRequest)
	if !ok {
		return fmt3.Errorf("that is not of type *WafRequest")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt3.Errorf("that is type *WafRequest but is nil && this != nil")
	} else if this == nil {
		return fmt3.Errorf("that is type *WafRequestbut is not nil && this == nil")
	}
	if this.Service != nil && that1.Service != nil {
		if *this.Service != *that1.Service {
			return fmt3.Errorf("Service this(%v) Not Equal that(%v)", *this.Service, *that1.Service)
		}
	} else if this.Service != nil {
		return fmt3.Errorf("this.Service == nil && that.Service != nil")
	} else if that1.Service != nil {
		return fmt3.Errorf("Service this(%v) Not Equal that(%v)", this.Service, that1.Service)
	}
	if this.Signature != nil && that1.Signature != nil {
		if *this.Signature != *that1.Signature {
			return fmt3.Errorf("Signature this(%v) Not Equal that(%v)", *this.Signature, *that1.Signature)
		}
	} else if this.Signature != nil {
		return fmt3.Errorf("this.Signature == nil && that.Signature != nil")
	} else if that1.Signature != nil {
		return fmt3.Errorf("Signature this(%v) Not Equal that(%v)", this.Signature, that1.Signature)
	}
	if !this.Req.Equal(that1.Req) {
		return fmt3.Errorf("Req this(%v) Not Equal that(%v)", this.Req, that1.Req)
	}
	if this.Clientip != nil && that1.Clientip != nil {
		if *this.Clientip != *that1.Clientip {
			return fmt3.Errorf("Clientip this(%v) Not Equal that(%v)", *this.Clientip, *that1.Clientip)
		}
	} else if this.Clientip != nil {
		return fmt3.Errorf("this.Clientip == nil && that.Clientip != nil")
	} else if that1.Clientip != nil {
		return fmt3.Errorf("Clientip this(%v) Not Equal that(%v)", this.Clientip, that1.Clientip)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt3.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *WafRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*WafRequest)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Service != nil && that1.Service != nil {
		if *this.Service != *that1.Service {
			return false
		}
	} else if this.Service != nil {
		return false
	} else if that1.Service != nil {
		return false
	}
	if this.Signature != nil && that1.Signature != nil {
		if *this.Signature != *that1.Signature {
			return false
		}
	} else if this.Signature != nil {
		return false
	} else if that1.Signature != nil {
		return false
	}
	if !this.Req.Equal(that1.Req) {
		return false
	}
	if this.Clientip != nil && that1.Clientip != nil {
		if *this.Clientip != *that1.Clientip {
			return false
		}
	} else if this.Clientip != nil {
		return false
	} else if that1.Clientip != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *WafResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt3.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*WafResponse)
	if !ok {
		return fmt3.Errorf("that is not of type *WafResponse")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt3.Errorf("that is type *WafResponse but is nil && this != nil")
	} else if this == nil {
		return fmt3.Errorf("that is type *WafResponsebut is not nil && this == nil")
	}
	if this.Code != nil && that1.Code != nil {
		if *this.Code != *that1.Code {
			return fmt3.Errorf("Code this(%v) Not Equal that(%v)", *this.Code, *that1.Code)
		}
	} else if this.Code != nil {
		return fmt3.Errorf("this.Code == nil && that.Code != nil")
	} else if that1.Code != nil {
		return fmt3.Errorf("Code this(%v) Not Equal that(%v)", this.Code, that1.Code)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt3.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *WafResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*WafResponse)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Code != nil && that1.Code != nil {
		if *this.Code != *that1.Code {
			return false
		}
	} else if this.Code != nil {
		return false
	} else if that1.Code != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
